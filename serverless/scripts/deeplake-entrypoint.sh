#!/bin/bash
# deeplake-entrypoint.sh
# Wrapper entrypoint for pg_deeplake containers.
#
# Writes AWS credentials to a tmpfs-backed file (/dev/shm) so they are
# NEVER persisted to the data volume. The file is included by postgresql.conf
# via include_if_exists and is recreated on every container start.
#
# This replaces the old approach of ALTER SYSTEM SET deeplake.creds which
# wrote credentials to postgresql.auto.conf on persistent storage.

set -e

# Only write creds file if we have AWS credentials (skip for IRSA/local).
if [ -n "${AWS_ACCESS_KEY_ID:-}" ] && [ -n "${AWS_SECRET_ACCESS_KEY:-}" ]; then
    CREDS_JSON="{\"aws_access_key_id\":\"${AWS_ACCESS_KEY_ID}\",\"aws_secret_access_key\":\"${AWS_SECRET_ACCESS_KEY}\",\"session_token\":\"${AWS_SESSION_TOKEN:-}\"}"
    # Escape single quotes for PostgreSQL GUC value
    CREDS_JSON_ESCAPED=${CREDS_JSON//\'/\'\'}

    cat > /dev/shm/deeplake-creds.conf <<EOF
# Auto-generated by deeplake-entrypoint.sh â€” do not edit
# Credentials stored on tmpfs (never written to persistent storage)
deeplake.creds = '${CREDS_JSON_ESCAPED}'
EOF
    chmod 600 /dev/shm/deeplake-creds.conf
    echo "deeplake-entrypoint: wrote credentials to /dev/shm/deeplake-creds.conf (tmpfs)"
else
    echo "deeplake-entrypoint: no AWS credentials set (using IRSA or local storage)"
fi

# Delegate to the official PostgreSQL Docker entrypoint
exec docker-entrypoint.sh "$@"
